% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/roll.R
\name{roll}
\alias{roll}
\title{Rolling Window function}
\usage{
roll(x, .f, ..., width = 1, extend = FALSE)
}
\arguments{
\item{x}{a vector passed into \code{.f}}

\item{.f}{a function or formula

  If a \strong{function}, it is used as is.

  If a \strong{formula}, e.g. \code{~ .x + 2}, it is converted to a
  function with two arguments, \code{.x} or \code{.} and \code{.y}. This
  allows you to create very compact anonymous functions with up to
  two inputs.}

\item{...}{further arguments to pass .f}

\item{width}{the width of the window}

\item{extend}{extend the window as it rolls (logical)}
}
\description{
A simple roll function, "rolling the window" across a series of data,
applying a function, to produce a vector of results
}
\examples{
# Simulate 4 years of daily returns
x <- rnorm(1000)
# compute the historical var across a window of a year
roll(x, var_historical, conf = 0.8, width = 250)

Really the decision lies with:
if kept simple, we map(df, ~ roll(~ .f(.x)))
but this means we cannot use roll to compute
functions that require interactions like cov(x,y)

That seems like the best way to deal with dataframes
}
